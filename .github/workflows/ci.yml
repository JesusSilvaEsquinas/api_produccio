# Nom "humà" del workflow. Així és com el veurem a la pestanya Actions.
name: CI (Laravel)

# Bloc que defineix QUAN s'executa el workflow.
on:
  # 1) Es dispara en fer push a main, jesus i a branques de feature.
  push:
    branches:
      - main
      - jesus
      - 'feature/*'
  # 2) També es dispara quan s’obre/actualitza un pull request cap a main.
  pull_request:
    branches:
      - main

# Bloc de feines (jobs) que s’executaran.
jobs:
  # Definim un job anomenat 'tests' (el nom és lliure; aquí indica que farà proves).
  tests:
    # Indiquem a GitHub quin tipus de màquina virtual ha d’usar.
    # 'ubuntu-latest' és l’últim Ubuntu que ofereix GitHub (normalment la millor opció per PHP).
    runs-on: ubuntu-latest

    
    # Llista ordenada de passos dins del job 'tests'.
    steps:
      # Pas 1: descarregar el codi del repositori al runner.
      - name: Checkout
        # 'uses' vol dir que fem servir una "action" pública del Marketplace.
        # actions/checkout@v4 clona el repo a la màquina del job.
        uses: actions/checkout@v4

      # Pas 2: instal·lar PHP i extensions necessàries per a Laravel.
      - name: Set up PHP
        # Action específica per gestionar versions/ext dels PHP Runtimes.
        uses: shivammathur/setup-php@v2
        # 'with' passa paràmetres a l'action.
        with:
          # Versió de PHP que volem al runner.
          php-version: '8.2'
          # Llista d’extensions que necessitem al projecte.
          # mbstring i bcmath són habituals a Laravel; pdo_sqlite per fer tests amb SQLite.
          extensions: mbstring, bcmath, pdo_sqlite
          # Desactivem la cobertura (xdebug) per fer el job més ràpid.
          coverage: none

      # Pas 3: cachejar el directori 'vendor' perquè els 'composer install' siguin molt més ràpids
      # a execucions futures si no canvia el lockfile.
      - name: Cache Composer
        uses: actions/cache@v4
        with:
          # 'path' indica què volem cachejar: el directori de dependències PHP.
          path: vendor
          # 'key' identifica la "clau" del cache. Si canvia, es crea un cache nou.
          # Fem servir una expressió de GitHub ${{ ... }} per construir la clau.
          # Afegim el sistema operatiu i el hash del composer.lock (si canvia, el cache deixa de servir).
          key: ${{ runner.os }}-php-${{ hashFiles('**/composer.lock') }}

      # Pas 4: instal·lar les dependències de Composer del projecte.
      - name: Install Composer dependencies
        # 'run' executa una comanda de shell a la màquina del job.
        # --no-progress: menys soroll als logs
        # --prefer-dist: baixa paquets ja empaquetats (més ràpid)
        # --optimize-autoloader: millora el temps de càrrega en producció/CI
        run: composer install --no-progress --prefer-dist --optimize-autoloader

      # Pas 4.1: configurar Node.js per poder construir els assets de Vite.
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Pas 4.2: instal·lar dependències de Node (frontend).
      - name: Install Node dependencies
        run: npm ci

      # Pas 4.3: construir els assets de Vite perquè existeixi public/build/manifest.json.
      - name: Build frontend assets
        run: npm run build

      # Pas 5: preparar l’entorn de proves.
      - name: Prepare environment
        # El tub '|' indica "multilínia": executarem aquestes comandes, una rere l’altra, al mateix pas.
        run: |
          # 5.1 Copiem l'exemple d'entorn a .env (a CI no exposem secrets; usem defaults).
          cp .env.example .env
          # 5.2 Generem l’APP_KEY necessària per a Laravel (encriptació, sessions, etc.).
          php artisan key:generate
          # 5.3 Creem la base de dades SQLite (fitxer buit). Ideal per a tests en CI.
          touch database/database.sqlite
          # 5.4 Apliquem migracions perquè les taules existeixin abans de provar.
          # --force evita que Artisan demani confirmació en entorns no interactius.
          php artisan migrate --force

      # Pas 5.1: mostrar informació del context de l'execució (ideal per demostrar merges a main).
      - name: Show GitHub context
        run: |
          echo "Workflow: $GITHUB_WORKFLOW"
          echo "Job: $GITHUB_JOB"
          echo "Event: $GITHUB_EVENT_NAME"
          echo "Ref: $GITHUB_REF"
          echo "Actor: $GITHUB_ACTOR"

      # Pas 6: executar els tests de Laravel.
      - name: Run tests
        # --no-coverage: no calculem cobertura (més ràpid per a una demo bàsica).
        # (Laravel invoca PHPUnit o Pest segons la config del projecte.)
        run: php artisan test --no-coverage

  # Job de desplegament a Laravel Cloud. Només s'executa si 'tests' ha anat bé.
  auto-merge:
    needs: tests
    if: github.event_name == 'push' && github.ref != 'refs/heads/main' && !contains(github.event.head_commit.message, 'Merge pull request')
    runs-on: ubuntu-latest
    steps:
      - name: Debug Info
        run: |
          echo "=== Debug Information ==="
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Ref name: ${{ github.ref_name }}"
          echo "Head commit message: ${{ github.event.head_commit.message }}"
          echo "Actor: ${{ github.actor }}"
          echo "Repository: ${{ github.repository }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "SHA: ${{ github.sha }}"
          echo "========================="

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para el historial completo de git
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git config --global pull.rebase false
          git remote -v
          git branch -a

      - name: Merge into main
        run: |
          echo "Fetching main branch..."
          git fetch origin main:main
          
          echo "Current branch: $(git branch --show-current)"
          echo "Available branches:"
          git branch -a
          
          echo "Checking out main..."
          git checkout main
          
          echo "Pulling latest changes..."
          git pull origin main
          
          echo "Merging ${{ github.ref_name }} into main..."
          git merge --no-ff ${{ github.ref_name }} -m "Auto-merge ${{ github.ref_name }} into main [skip ci]"
          
          echo "Pushing changes to main..."
          # Usar el token de autenticación para el push
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          git push origin main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy:
    # Aquest job DEPÈN del job 'tests': si falla, 'deploy' ni tan sols s'executa.
    needs: [tests, auto-merge]
    runs-on: ubuntu-latest
    # Només volem desplegar en pushes a main, no en pull requests.
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Trigger Laravel Cloud deploy
        # Fem una petició HTTP al "deploy hook" de Laravel Cloud.
        # Guarda la URL del hook com a secret LARAVEL_CLOUD_DEPLOY_HOOK al repo.
        run: |
          echo "Calling Laravel Cloud deploy hook..."
          curl -f -X POST "${LARAVEL_CLOUD_DEPLOY_HOOK}"
        env:
          LARAVEL_CLOUD_DEPLOY_HOOK: ${{ secrets.LARAVEL_CLOUD_DEPLOY_HOOK }}
          #Probar un test que no funcione